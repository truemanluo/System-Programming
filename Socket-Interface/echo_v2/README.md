1. 针对`echo_v1`中无法实现多个客户端连接服务器的问题，`echo_v2`中改进如下：

- 将等待连接的`accept`放到死循环中，当检测到连接请求时，`fork`一个子进程用于数据传输，父进程继续阻塞，等待连接请求

> 值得注意的几点：
>   - 子进程会继承父进程中打开的文件，但子进程不需要监听描述符，因此需要将它释放
>   - 同理，父进程中不需要用于数据传输的已连接描述符，因此也需要将其释放
>   - 为什么需要创建子进程？
>   
>       A：客户端只进行一次连接，如果仅仅是将`accept`放入死循环中，则服务器检测不到连接请求，会阻塞在此处
>   - 为什么多个客户端连接同一服务器时文件描述符相同？
> 
>       A: 因为父进程在连接之后关闭了`connfd`，kernel总是从最小的文件描述符开始分配
>   - 当客户端控制台没有输入时，服务器被阻塞在`read`处，直到有新的数据过来（此处需要研究`read`和`fputs`等`IO`函数的特性）


2. 针对`echo_v1`中服务器端无法捕获客户端关闭的消息的问题，用读入的字节数进行判断（输入ctrl-c则读入字节数为0），并退出与客户端对应的数据传输子进程

3. 用设置`SO_REUSEADDR` 开启来避免`TIME_WAIT`

总的来说，`echo_v2`**是为每个连接新建一个进程来实现并发**，父进程用于监听，子进程用于数据传输


![](https://gblobscdn.gitbook.com/assets%2F-MRP-_mTHVixnnXPCTr3%2F-Md5H0zdgQRpPK6MjEdb%2F-Md7NfOzK6DqjksTMV8g%2Fimage.png?alt=media&token=13d99b61-280d-46f4-b9b1-e8a59fd22379)

最后，很重要的一点：客户端和服务器之间的`while`循环被阻塞的位置
- 客户端程序中，程序被阻塞在等待`stdin`处，一旦有输入，循环体开始执行，将输入写入`clientfd`
- 服务器程序中，程序被组赛在`read`处，原因是当文件描述符为空时`read`一直等待

