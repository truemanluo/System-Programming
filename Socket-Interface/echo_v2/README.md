针对`echo_v1`中无法实现多个客户端连接服务器的问题，`echo_v2`中改进如下：

- 将等待连接的`accept`放到死循环中，当检测到连接请求时，`fork`一个子进程用于数据传输，父进程继续阻塞，等待连接请求

> 值得注意的几点：
>   - 子进程会继承父进程中打开的文件，但子进程不需要监听描述符，因此需要将它释放
>   - 同理，父进程中不需要用于数据传输的已连接描述符，因此也需要将其释放
>   - 为什么需要创建子进程？
>   
>       A：客户端只进行一次连接，如果仅仅是将`accept`放入死循环中，则服务器检测不到连接请求，会阻塞在此处
>   - 为什么多个客户端连接同一服务器时文件描述符相同？
>       A: 因为父进程在连接之后关闭了`connfd`，kernel总是从最小的文件描述符开始分配